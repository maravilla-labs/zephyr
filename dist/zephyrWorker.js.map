{"version":3,"file":"zephyrWorker.js","sources":["../lib/zephyrWorker.js"],"sourcesContent":["/**\n * Zephyr - Lightweight Service Worker Caching Library\n *\n * @version 0.2.0\n * @license Apache-2.0\n * @copyright 2019-2025 SOLUTAS GmbH\n * @see https://github.com/maravilla-labs/zephyr\n */\n\n// ============================================================================\n// Configuration & Constants\n// ============================================================================\n\nconst DB_NAME = 'zephyr-cache-db';\nconst DB_VERSION = 3; // Bumped for new schema\nconst STORE_NAME = 'responses';\nconst DEFAULT_TIMEOUT = 10000;\nconst DEFAULT_MAX_ENTRIES = 100;\nconst DEFAULT_MAX_STALE_AGE = 1440; // 24 hours in minutes\nconst DEFAULT_QUOTA_MAX_SIZE = 50 * 1024 * 1024; // 50MB\nconst DEFAULT_QUOTA_WARNING_THRESHOLD = 0.8;\n\n// Global state\nlet debugMode = false;\nlet globalConfig = null;\nlet manifestPollInterval = null;\nlet lastManifestVersion = null;\nlet currentStorageSize = 0;\n\n// Stats tracking\nconst stats = {\n  hits: 0,\n  misses: 0,\n  errors: 0,\n  evictions: 0,\n  revalidations: 0,\n  prefetches: 0\n};\n\n// ============================================================================\n// Utility Functions\n// ============================================================================\n\nfunction debugLog(message, ...args) {\n  if (debugMode) {\n    console.log(`[Zephyr] ${message}`, ...args);\n  }\n}\n\nfunction logCacheHit(url) {\n  if (debugMode) {\n    console.log('%c[Zephyr] Cache HIT:%c %s',\n      'background: #4CAF50; color: white; padding: 2px 6px; border-radius: 3px;',\n      'color: #4CAF50;', url);\n  }\n}\n\nfunction logCacheMiss(url) {\n  if (debugMode) {\n    console.log('%c[Zephyr] Cache MISS:%c %s',\n      'background: #FF9800; color: white; padding: 2px 6px; border-radius: 3px;',\n      'color: #FF9800;', url);\n  }\n}\n\nfunction logRevalidation(url) {\n  if (debugMode) {\n    console.log('%c[Zephyr] Revalidating:%c %s',\n      'background: #2196F3; color: white; padding: 2px 6px; border-radius: 3px;',\n      'color: #2196F3;', url);\n  }\n}\n\nasync function hashPayload(payload) {\n  try {\n    const encoder = new TextEncoder();\n    const data = encoder.encode(payload);\n    const hashBuffer = await crypto.subtle.digest('SHA-256', data);\n    const hashArray = Array.from(new Uint8Array(hashBuffer));\n    return hashArray.map(b => b.toString(16).padStart(2, '0')).join('');\n  } catch (error) {\n    let hash = 0;\n    for (let i = 0; i < payload.length; i++) {\n      const char = payload.charCodeAt(i);\n      hash = ((hash << 5) - hash) + char;\n      hash = hash & hash;\n    }\n    return Math.abs(hash).toString(16);\n  }\n}\n\nasync function generateCacheKey(request) {\n  let key = request.url;\n  if (request.method === 'POST') {\n    try {\n      const payload = await request.clone().text();\n      const payloadHash = await hashPayload(payload);\n      key += `-${payloadHash}`;\n    } catch (error) {\n      debugLog('Failed to hash POST payload:', error.message);\n    }\n  }\n  return key;\n}\n\nfunction guessContentType(url) {\n  const extension = url.split('.').pop().split(/[#?]/)[0].toLowerCase();\n  const mimeTypes = {\n    'jpg': 'image/jpeg', 'jpeg': 'image/jpeg', 'png': 'image/png',\n    'gif': 'image/gif', 'webp': 'image/webp', 'svg': 'image/svg+xml',\n    'ico': 'image/x-icon', 'css': 'text/css', 'html': 'text/html',\n    'js': 'application/javascript', 'mjs': 'application/javascript',\n    'json': 'application/json', 'xml': 'application/xml', 'txt': 'text/plain',\n    'woff': 'font/woff', 'woff2': 'font/woff2', 'ttf': 'font/ttf',\n    'mp4': 'video/mp4', 'webm': 'video/webm', 'pdf': 'application/pdf',\n  };\n  return mimeTypes[extension] || 'application/octet-stream';\n}\n\nfunction fetchWithTimeout(request, timeout = DEFAULT_TIMEOUT) {\n  return new Promise((resolve, reject) => {\n    const controller = new AbortController();\n    const timeoutId = setTimeout(() => {\n      controller.abort();\n      reject(new Error(`Request timeout after ${timeout}ms`));\n    }, timeout);\n\n    fetch(request, { signal: controller.signal })\n      .then(response => { clearTimeout(timeoutId); resolve(response); })\n      .catch(error => { clearTimeout(timeoutId); reject(error); });\n  });\n}\n\n// ============================================================================\n// HTTP Header Parsing\n// ============================================================================\n\n/**\n * Parse Cache-Control header into directives\n */\nfunction parseCacheControl(header) {\n  if (!header) return {};\n  const directives = {};\n  header.split(',').forEach(part => {\n    const [key, value] = part.trim().split('=');\n    directives[key.toLowerCase()] = value ? parseInt(value, 10) : true;\n  });\n  return directives;\n}\n\n/**\n * Parse Expires header to timestamp\n */\nfunction parseExpires(header) {\n  if (!header) return null;\n  const date = new Date(header);\n  return isNaN(date.getTime()) ? null : date.getTime();\n}\n\n/**\n * Extract cache metadata from response headers\n */\nfunction extractCacheMetadata(response) {\n  const cacheControl = parseCacheControl(response.headers.get('Cache-Control'));\n  const expires = parseExpires(response.headers.get('Expires'));\n\n  return {\n    etag: response.headers.get('ETag'),\n    lastModified: response.headers.get('Last-Modified'),\n    maxAge: cacheControl['max-age'],\n    mustRevalidate: cacheControl['must-revalidate'] || cacheControl['no-cache'] === true,\n    noStore: cacheControl['no-store'] === true,\n    expires: expires,\n    sMaxAge: cacheControl['s-maxage']\n  };\n}\n\n/**\n * Calculate TTL from response headers or rule config\n */\nfunction calculateTTL(metadata, ruleTTL, respectHeaders = true) {\n  if (!respectHeaders) {\n    return ruleTTL;\n  }\n\n  // Priority: s-maxage > max-age > Expires > rule TTL\n  if (metadata.sMaxAge !== undefined) {\n    return metadata.sMaxAge / 60; // Convert seconds to minutes\n  }\n  if (metadata.maxAge !== undefined) {\n    return metadata.maxAge / 60;\n  }\n  if (metadata.expires) {\n    const ttlMs = metadata.expires - Date.now();\n    return Math.max(0, ttlMs / 60000);\n  }\n  return ruleTTL;\n}\n\n// ============================================================================\n// Response Validation\n// ============================================================================\n\nfunction shouldCacheResponse(response, metadata) {\n  if (!response.ok) {\n    debugLog('Not caching: response not ok (status:', response.status, ')');\n    return false;\n  }\n\n  if (metadata.noStore) {\n    debugLog('Not caching: Cache-Control: no-store');\n    return false;\n  }\n\n  if (response.headers.get('Set-Cookie')) {\n    debugLog('Not caching: response contains Set-Cookie header');\n    return false;\n  }\n\n  return true;\n}\n\n// ============================================================================\n// IndexedDB Operations\n// ============================================================================\n\nasync function openIndexedDB() {\n  return new Promise((resolve, reject) => {\n    const request = indexedDB.open(DB_NAME, DB_VERSION);\n\n    request.onerror = () => {\n      reject(new Error(`IndexedDB error: ${request.error?.message || 'Unknown error'}`));\n    };\n\n    request.onupgradeneeded = (event) => {\n      const db = event.target.result;\n\n      // Delete old store if exists (schema change)\n      if (db.objectStoreNames.contains(STORE_NAME)) {\n        db.deleteObjectStore(STORE_NAME);\n      }\n\n      const store = db.createObjectStore(STORE_NAME, { keyPath: 'url' });\n      store.createIndex('validUntil', 'validUntil', { unique: false });\n      store.createIndex('pattern', 'pattern', { unique: false });\n      store.createIndex('lastAccess', 'lastAccess', { unique: false });\n      store.createIndex('cachedAt', 'cachedAt', { unique: false });\n    };\n\n    request.onsuccess = () => resolve(request.result);\n  });\n}\n\nasync function storeResponseInIndexedDB(request, response, ttl, pattern, metadata = {}) {\n  try {\n    const db = await openIndexedDB();\n    const body = await response.clone().arrayBuffer();\n    const key = await generateCacheKey(request);\n    const bodySize = body.byteLength;\n\n    // Check quota before storing\n    if (globalConfig?.quota) {\n      const quotaCheck = await checkQuota(bodySize);\n      if (!quotaCheck.canStore) {\n        debugLog('Quota exceeded, applying strategy:', globalConfig.quota.onQuotaExceeded);\n        return;\n      }\n    }\n\n    const headers = {};\n    response.headers.forEach((value, headerKey) => {\n      if (headerKey.toLowerCase() !== 'set-cookie') {\n        headers[headerKey] = value;\n      }\n    });\n\n    if (!headers['content-type']) {\n      headers['content-type'] = guessContentType(request.url);\n    }\n\n    const now = Date.now();\n    const record = {\n      url: key,\n      body: body,\n      headers: headers,\n      status: response.status,\n      statusText: response.statusText,\n      validUntil: now + ttl * 60000,\n      lastAccess: now,\n      cachedAt: now,\n      pattern: pattern,\n      size: bodySize,\n      // HTTP cache metadata\n      etag: metadata.etag,\n      lastModified: metadata.lastModified,\n      mustRevalidate: metadata.mustRevalidate,\n      cacheVersion: metadata.cacheVersion\n    };\n\n    return new Promise((resolve, reject) => {\n      const tx = db.transaction(STORE_NAME, 'readwrite');\n      const store = tx.objectStore(STORE_NAME);\n      store.put(record);\n\n      tx.oncomplete = () => {\n        currentStorageSize += bodySize;\n        debugLog('Stored in cache:', key, `(${(bodySize/1024).toFixed(1)}KB)`);\n        resolve();\n      };\n\n      tx.onerror = () => {\n        stats.errors++;\n        reject(new Error(`Failed to store: ${tx.error?.message}`));\n      };\n    });\n  } catch (error) {\n    debugLog('Store error:', error.message);\n    stats.errors++;\n  }\n}\n\nasync function getResponseFromIndexedDB(request, options = {}) {\n  try {\n    const db = await openIndexedDB();\n    const key = await generateCacheKey(request);\n\n    return new Promise((resolve) => {\n      const tx = db.transaction(STORE_NAME, 'readwrite');\n      const store = tx.objectStore(STORE_NAME);\n      const getRequest = store.get(key);\n\n      getRequest.onerror = () => {\n        stats.errors++;\n        resolve({ response: null, record: null });\n      };\n\n      getRequest.onsuccess = () => {\n        const record = getRequest.result;\n\n        if (!record || !record.body || !record.headers) {\n          resolve({ response: null, record: null });\n          return;\n        }\n\n        const now = Date.now();\n        const isExpired = now > record.validUntil;\n        const isStale = isExpired;\n\n        // Check max stale age for fallback\n        const maxStaleAge = options.maxStaleAge || DEFAULT_MAX_STALE_AGE;\n        const staleAge = (now - record.validUntil) / 60000; // in minutes\n        const isTooStale = staleAge > maxStaleAge;\n\n        // Update last access time\n        record.lastAccess = now;\n        store.put(record);\n\n        const contentType = record.headers['content-type'] || 'application/octet-stream';\n        const blob = new Blob([record.body], { type: contentType });\n        const response = new Response(blob, {\n          status: record.status || 200,\n          statusText: record.statusText || 'OK',\n          headers: record.headers\n        });\n\n        resolve({\n          response,\n          record,\n          isExpired,\n          isStale,\n          isTooStale,\n          needsRevalidation: record.mustRevalidate || isExpired\n        });\n      };\n    });\n  } catch (error) {\n    debugLog('Cache retrieval error:', error.message);\n    stats.errors++;\n    return { response: null, record: null };\n  }\n}\n\nasync function deleteCacheEntry(key) {\n  try {\n    const db = await openIndexedDB();\n    return new Promise((resolve) => {\n      const tx = db.transaction(STORE_NAME, 'readwrite');\n      const store = tx.objectStore(STORE_NAME);\n\n      // Get size before delete for quota tracking\n      const getReq = store.get(key);\n      getReq.onsuccess = () => {\n        if (getReq.result?.size) {\n          currentStorageSize -= getReq.result.size;\n        }\n        store.delete(key);\n      };\n\n      tx.oncomplete = () => resolve(true);\n      tx.onerror = () => resolve(false);\n    });\n  } catch (error) {\n    return false;\n  }\n}\n\nasync function clearAllCache() {\n  try {\n    const db = await openIndexedDB();\n    return new Promise((resolve) => {\n      const tx = db.transaction(STORE_NAME, 'readwrite');\n      const store = tx.objectStore(STORE_NAME);\n      store.clear();\n      tx.oncomplete = () => {\n        currentStorageSize = 0;\n        debugLog('Cache cleared');\n        resolve(true);\n      };\n      tx.onerror = () => resolve(false);\n    });\n  } catch (error) {\n    return false;\n  }\n}\n\nasync function clearCacheByPattern(pattern) {\n  try {\n    const db = await openIndexedDB();\n    const regex = new RegExp(pattern);\n    let deleted = 0;\n    let freedBytes = 0;\n\n    return new Promise((resolve) => {\n      const tx = db.transaction(STORE_NAME, 'readwrite');\n      const store = tx.objectStore(STORE_NAME);\n      const request = store.openCursor();\n\n      request.onsuccess = (event) => {\n        const cursor = event.target.result;\n        if (cursor) {\n          if (regex.test(cursor.value.url)) {\n            freedBytes += cursor.value.size || 0;\n            cursor.delete();\n            deleted++;\n          }\n          cursor.continue();\n        }\n      };\n\n      tx.oncomplete = () => {\n        currentStorageSize -= freedBytes;\n        debugLog(`Cleared ${deleted} entries matching: ${pattern}`);\n        resolve(deleted);\n      };\n      tx.onerror = () => resolve(0);\n    });\n  } catch (error) {\n    return 0;\n  }\n}\n\nasync function clearCacheByUrl(url) {\n  return deleteCacheEntry(url);\n}\n\nasync function getCacheStats() {\n  try {\n    const db = await openIndexedDB();\n    return new Promise((resolve) => {\n      const tx = db.transaction(STORE_NAME, 'readonly');\n      const store = tx.objectStore(STORE_NAME);\n      const countRequest = store.count();\n\n      countRequest.onsuccess = () => {\n        const result = {\n          ...stats,\n          entries: countRequest.result,\n          storageUsed: currentStorageSize,\n          storageUsedMB: (currentStorageSize / (1024 * 1024)).toFixed(2),\n          hitRate: stats.hits + stats.misses > 0\n            ? (stats.hits / (stats.hits + stats.misses) * 100).toFixed(1) + '%'\n            : 'N/A'\n        };\n        // Only include prefetches if eager caching is configured\n        if (globalConfig?.eagerCache) {\n          result.prefetches = stats.prefetches;\n        }\n        resolve(result);\n      };\n\n      countRequest.onerror = () => {\n        resolve({ ...stats, entries: 0, hitRate: 'N/A' });\n      };\n    });\n  } catch (error) {\n    return { ...stats, entries: 0, hitRate: 'N/A', error: error.message };\n  }\n}\n\nasync function enforceCacheLimits(pattern, maxEntries = DEFAULT_MAX_ENTRIES) {\n  try {\n    const db = await openIndexedDB();\n\n    return new Promise((resolve) => {\n      const tx = db.transaction(STORE_NAME, 'readwrite');\n      const store = tx.objectStore(STORE_NAME);\n      const index = store.index('pattern');\n      const request = index.getAll(pattern);\n\n      request.onsuccess = () => {\n        const entries = request.result;\n        if (entries.length <= maxEntries) {\n          resolve(0);\n          return;\n        }\n\n        entries.sort((a, b) => a.lastAccess - b.lastAccess);\n        const toDelete = entries.slice(0, entries.length - maxEntries);\n\n        toDelete.forEach(entry => {\n          store.delete(entry.url);\n          currentStorageSize -= entry.size || 0;\n          stats.evictions++;\n        });\n\n        debugLog(`Evicted ${toDelete.length} entries for pattern: ${pattern}`);\n        resolve(toDelete.length);\n      };\n\n      request.onerror = () => resolve(0);\n    });\n  } catch (error) {\n    return 0;\n  }\n}\n\n// ============================================================================\n// Quota Monitoring\n// ============================================================================\n\nasync function checkQuota(additionalBytes = 0) {\n  if (!globalConfig?.quota) {\n    return { canStore: true, usage: 0, percentage: 0 };\n  }\n\n  const maxSize = globalConfig.quota.maxSize || DEFAULT_QUOTA_MAX_SIZE;\n  const warningThreshold = globalConfig.quota.warningThreshold || DEFAULT_QUOTA_WARNING_THRESHOLD;\n  const projectedSize = currentStorageSize + additionalBytes;\n  const percentage = projectedSize / maxSize;\n\n  // Warning threshold\n  if (percentage >= warningThreshold && percentage < 1) {\n    debugLog(`Quota warning: ${(percentage * 100).toFixed(1)}% used`);\n    notifyQuotaWarning(percentage);\n  }\n\n  // Exceeded\n  if (percentage >= 1) {\n    const strategy = globalConfig.quota.onQuotaExceeded || 'evict-lru';\n\n    switch (strategy) {\n      case 'evict-lru':\n        await evictLRUEntries(additionalBytes);\n        return { canStore: true, usage: currentStorageSize, percentage };\n      case 'stop-caching':\n        return { canStore: false, usage: currentStorageSize, percentage };\n      case 'clear-all':\n        await clearAllCache();\n        return { canStore: true, usage: 0, percentage: 0 };\n      default:\n        return { canStore: false, usage: currentStorageSize, percentage };\n    }\n  }\n\n  return { canStore: true, usage: currentStorageSize, percentage };\n}\n\nasync function evictLRUEntries(bytesNeeded) {\n  try {\n    const db = await openIndexedDB();\n\n    return new Promise((resolve) => {\n      const tx = db.transaction(STORE_NAME, 'readwrite');\n      const store = tx.objectStore(STORE_NAME);\n      const index = store.index('lastAccess');\n      const request = index.openCursor();\n\n      let freedBytes = 0;\n\n      request.onsuccess = (event) => {\n        const cursor = event.target.result;\n        if (cursor && freedBytes < bytesNeeded) {\n          freedBytes += cursor.value.size || 0;\n          cursor.delete();\n          stats.evictions++;\n          cursor.continue();\n        }\n      };\n\n      tx.oncomplete = () => {\n        currentStorageSize -= freedBytes;\n        debugLog(`Evicted entries to free ${(freedBytes/1024).toFixed(1)}KB`);\n        resolve(freedBytes);\n      };\n    });\n  } catch (error) {\n    return 0;\n  }\n}\n\nfunction notifyQuotaWarning(percentage) {\n  // Notify via postMessage to all clients\n  if (typeof clients !== 'undefined') {\n    clients.matchAll().then(clientList => {\n      clientList.forEach(client => {\n        client.postMessage({\n          type: 'zephyr-quota-warning',\n          percentage: percentage,\n          used: currentStorageSize,\n          max: globalConfig?.quota?.maxSize || DEFAULT_QUOTA_MAX_SIZE\n        });\n      });\n    });\n  }\n}\n\nasync function getQuotaUsage() {\n  const maxSize = globalConfig?.quota?.maxSize || DEFAULT_QUOTA_MAX_SIZE;\n  return {\n    used: currentStorageSize,\n    max: maxSize,\n    percentage: (currentStorageSize / maxSize * 100).toFixed(1) + '%',\n    available: maxSize - currentStorageSize\n  };\n}\n\n// ============================================================================\n// Manifest-based Invalidation\n// ============================================================================\n\nasync function startManifestPolling(config) {\n  if (!config?.invalidation?.type === 'manifest' || !config.invalidation.url) {\n    return;\n  }\n\n  const interval = config.invalidation.interval || 60000;\n  const url = config.invalidation.url;\n  const parser = config.invalidation.parser || (r => r.json());\n\n  debugLog('Starting manifest polling:', url, 'interval:', interval);\n\n  const pollManifest = async () => {\n    try {\n      const response = await fetch(url, { cache: 'no-store' });\n      if (!response.ok) {\n        debugLog('Manifest fetch failed:', response.status);\n        return;\n      }\n\n      const manifest = await parser(response);\n\n      // Check global version change\n      if (manifest.version && manifest.version !== lastManifestVersion) {\n        debugLog('Manifest version changed:', lastManifestVersion, '->', manifest.version);\n        lastManifestVersion = manifest.version;\n\n        // Invalidate based on pattern timestamps\n        if (manifest.patterns) {\n          await invalidateByManifest(manifest.patterns);\n        }\n      }\n    } catch (error) {\n      debugLog('Manifest poll error:', error.message);\n    }\n  };\n\n  // Initial poll\n  await pollManifest();\n\n  // Set up interval\n  manifestPollInterval = setInterval(pollManifest, interval);\n}\n\nasync function invalidateByManifest(patterns) {\n  try {\n    const db = await openIndexedDB();\n\n    return new Promise((resolve) => {\n      const tx = db.transaction(STORE_NAME, 'readwrite');\n      const store = tx.objectStore(STORE_NAME);\n      const request = store.openCursor();\n      let invalidated = 0;\n\n      request.onsuccess = (event) => {\n        const cursor = event.target.result;\n        if (cursor) {\n          const record = cursor.value;\n\n          // Check each pattern\n          for (const [pattern, timestamp] of Object.entries(patterns)) {\n            try {\n              const regex = new RegExp(pattern);\n              if (regex.test(record.url)) {\n                const patternTime = new Date(timestamp).getTime();\n                if (record.cachedAt < patternTime) {\n                  cursor.delete();\n                  currentStorageSize -= record.size || 0;\n                  invalidated++;\n                  debugLog('Invalidated by manifest:', record.url);\n                }\n              }\n            } catch (e) {\n              // Invalid regex, skip\n            }\n          }\n          cursor.continue();\n        }\n      };\n\n      tx.oncomplete = () => {\n        if (invalidated > 0) {\n          debugLog(`Manifest invalidation: ${invalidated} entries removed`);\n        }\n        resolve(invalidated);\n      };\n    });\n  } catch (error) {\n    debugLog('Manifest invalidation error:', error.message);\n    return 0;\n  }\n}\n\nfunction stopManifestPolling() {\n  if (manifestPollInterval) {\n    clearInterval(manifestPollInterval);\n    manifestPollInterval = null;\n    debugLog('Stopped manifest polling');\n  }\n}\n\n// ============================================================================\n// Conditional Requests (ETag/Last-Modified)\n// ============================================================================\n\nasync function revalidateWithServer(request, record, timeout) {\n  const headers = new Headers(request.headers);\n\n  if (record.etag) {\n    headers.set('If-None-Match', record.etag);\n  }\n  if (record.lastModified) {\n    headers.set('If-Modified-Since', record.lastModified);\n  }\n\n  const conditionalRequest = new Request(request.url, {\n    method: request.method,\n    headers: headers,\n    mode: request.mode,\n    credentials: request.credentials,\n    cache: 'no-store'\n  });\n\n  try {\n    logRevalidation(request.url);\n    stats.revalidations++;\n\n    const response = await fetchWithTimeout(conditionalRequest, timeout);\n\n    if (response.status === 304) {\n      debugLog('304 Not Modified, using cached response');\n      return { notModified: true, response: null };\n    }\n\n    return { notModified: false, response };\n  } catch (error) {\n    debugLog('Revalidation failed:', error.message);\n    return { notModified: false, response: null, error };\n  }\n}\n\n// ============================================================================\n// Fallback Strategies\n// ============================================================================\n\nfunction getFallbackStrategy(rule) {\n  if (!rule.fallback) {\n    return { strategy: 'stale-if-error', maxStaleAge: DEFAULT_MAX_STALE_AGE };\n  }\n  return {\n    strategy: rule.fallback.strategy || 'stale-if-error',\n    maxStaleAge: rule.fallback.maxStaleAge || DEFAULT_MAX_STALE_AGE\n  };\n}\n\n// ============================================================================\n// Debug & Logging\n// ============================================================================\n\nasync function logAllCacheRecords() {\n  if (!debugMode) return;\n\n  try {\n    const db = await openIndexedDB();\n    const tx = db.transaction(STORE_NAME, 'readonly');\n    const store = tx.objectStore(STORE_NAME);\n    const request = store.getAll();\n\n    request.onsuccess = () => {\n      const records = request.result;\n      if (records.length === 0) {\n        console.log('[Zephyr] Cache is empty');\n        return;\n      }\n\n      const tableData = records.map(r => ({\n        url: r.url.substring(0, 50) + (r.url.length > 50 ? '...' : ''),\n        size: r.size ? `${(r.size / 1024).toFixed(1)}KB` : 'N/A',\n        validUntil: new Date(r.validUntil).toISOString(),\n        etag: r.etag ? 'Yes' : 'No',\n        mustRevalidate: r.mustRevalidate ? 'Yes' : 'No'\n      }));\n\n      console.log('[Zephyr] Cache contents:');\n      console.table(tableData);\n    };\n  } catch (error) {\n    console.log('[Zephyr] Error reading cache:', error.message);\n  }\n}\n\n// ============================================================================\n// Eager Caching (Precache & Prefetch)\n// ============================================================================\n\n/**\n * Find a matching rule for a URL and method\n */\nfunction findMatchingRule(url, method = 'GET') {\n  if (!globalConfig?.rules) return null;\n  return globalConfig.rules.find(rule => {\n    try {\n      const regex = new RegExp(rule.test);\n      return regex.test(url) && (!rule.method || rule.method === method);\n    } catch {\n      return false;\n    }\n  });\n}\n\n/**\n * Check if URL matches any precache pattern\n */\nfunction matchesPrecachePattern(url) {\n  const patterns = globalConfig?.eagerCache?.precache?.patterns || [];\n  return patterns.some(pattern => {\n    try {\n      const regex = new RegExp(pattern);\n      return regex.test(url);\n    } catch {\n      return false;\n    }\n  });\n}\n\n/**\n * Execute precache during SW install\n */\nasync function executePrecache(precacheConfig) {\n  const { urls = [], retries = 2, failSilently = true } = precacheConfig;\n\n  if (urls.length === 0) {\n    debugLog('No URLs to precache');\n    return;\n  }\n\n  // Deduplicate URLs\n  const urlsToCache = [...new Set(urls)];\n\n  debugLog(`Precaching ${urlsToCache.length} URLs`);\n\n  const results = await Promise.allSettled(\n    urlsToCache.map(url => precacheUrl(url, retries))\n  );\n\n  const succeeded = results.filter(r => r.status === 'fulfilled').length;\n  const failed = results.filter(r => r.status === 'rejected').length;\n\n  debugLog(`Precache complete: ${succeeded} succeeded, ${failed} failed`);\n\n  // Notify clients of precache status\n  notifyPrecacheComplete(succeeded, failed, urlsToCache.length);\n\n  if (failed > 0 && !failSilently) {\n    throw new Error(`Precache failed: ${failed} of ${urlsToCache.length} URLs failed`);\n  }\n}\n\n/**\n * Precache a single URL with retries\n */\nasync function precacheUrl(url, retriesLeft) {\n  try {\n    // Normalize URL\n    const absoluteUrl = new URL(url, self.location.origin).href;\n\n    // Find matching rule for TTL\n    const matchingRule = findMatchingRule(absoluteUrl, 'GET');\n    const ttl = matchingRule ? parseInt(matchingRule.cache, 10) : 60;\n\n    // Check if already cached\n    const cached = await getResponseFromIndexedDB({ url: absoluteUrl, method: 'GET' });\n    if (cached.response && !cached.isExpired) {\n      debugLog('Precache skip (already cached):', absoluteUrl);\n      return { status: 'already-cached', url: absoluteUrl };\n    }\n\n    // Fetch the resource\n    const response = await fetch(absoluteUrl, {\n      method: 'GET',\n      credentials: 'same-origin'\n    });\n\n    if (!response.ok) {\n      throw new Error(`HTTP ${response.status}`);\n    }\n\n    const metadata = extractCacheMetadata(response);\n\n    if (shouldCacheResponse(response, metadata)) {\n      const pattern = matchingRule?.test || 'precache';\n      await storeResponseInIndexedDB(\n        { url: absoluteUrl, method: 'GET' },\n        response,\n        ttl,\n        pattern,\n        metadata\n      );\n      stats.prefetches++;\n      debugLog('Precached:', absoluteUrl);\n      return { status: 'precached', url: absoluteUrl };\n    }\n\n    return { status: 'not-cacheable', url: absoluteUrl };\n  } catch (error) {\n    if (retriesLeft > 0) {\n      debugLog(`Precache retry (${retriesLeft} left):`, url);\n      await new Promise(resolve => setTimeout(resolve, 1000));\n      return precacheUrl(url, retriesLeft - 1);\n    }\n    throw error;\n  }\n}\n\n/**\n * Handle prefetch request from client (link prediction)\n */\nasync function handlePrefetch(url) {\n  try {\n    // Normalize URL\n    const absoluteUrl = new URL(url, self.location.origin).href;\n\n    // Check if already cached\n    const cached = await getResponseFromIndexedDB({ url: absoluteUrl, method: 'GET' });\n    if (cached.response && !cached.isExpired) {\n      return { status: 'already-cached', url: absoluteUrl };\n    }\n\n    // Find matching rule\n    const matchingRule = findMatchingRule(absoluteUrl, 'GET');\n\n    // Check quota before fetching\n    const quotaCheck = await checkQuota(0);\n    if (!quotaCheck.canStore) {\n      return { status: 'quota-exceeded', url: absoluteUrl };\n    }\n\n    // Fetch with low priority\n    const response = await fetch(absoluteUrl, {\n      method: 'GET',\n      credentials: 'same-origin'\n    });\n\n    if (!response.ok) {\n      return { status: 'fetch-failed', url: absoluteUrl, httpStatus: response.status };\n    }\n\n    const metadata = extractCacheMetadata(response);\n\n    if (!shouldCacheResponse(response, metadata)) {\n      return { status: 'not-cacheable', url: absoluteUrl };\n    }\n\n    // Calculate TTL\n    const ruleTTL = matchingRule ? parseInt(matchingRule.cache, 10) : 60;\n    const respectHeaders = globalConfig?.invalidation?.respectHttpHeaders !== false;\n    const ttl = calculateTTL(metadata, ruleTTL, respectHeaders);\n\n    const pattern = matchingRule?.test || 'prefetch';\n\n    await storeResponseInIndexedDB(\n      { url: absoluteUrl, method: 'GET' },\n      response,\n      ttl,\n      pattern,\n      metadata\n    );\n\n    // Enforce limits if rule exists\n    if (matchingRule?.maxEntries) {\n      await enforceCacheLimits(matchingRule.test, matchingRule.maxEntries);\n    }\n\n    stats.prefetches++;\n    debugLog('Prefetched:', absoluteUrl);\n    return { status: 'prefetched', url: absoluteUrl };\n\n  } catch (error) {\n    debugLog('Prefetch error:', error.message);\n    return { status: 'error', url, error: error.message };\n  }\n}\n\n/**\n * Notify clients of precache completion\n */\nfunction notifyPrecacheComplete(succeeded, failed, total) {\n  if (typeof clients !== 'undefined') {\n    clients.matchAll().then(clientList => {\n      clientList.forEach(client => {\n        client.postMessage({\n          type: 'zephyr-precache-complete',\n          succeeded,\n          failed,\n          total\n        });\n      });\n    });\n  }\n}\n\n// ============================================================================\n// Main Initialization\n// ============================================================================\n\nfunction initZephyr(config) {\n  if (!config || !Array.isArray(config.rules)) {\n    console.error('[Zephyr] Invalid configuration: missing rules array');\n    return;\n  }\n\n  globalConfig = config;\n\n  // Set defaults for invalidation\n  const invalidation = config.invalidation || {};\n  const respectHttpHeaders = invalidation.respectHttpHeaders !== false;\n\n  // Validate rules\n  config.rules.forEach((rule, index) => {\n    if (!rule.test) {\n      console.error(`[Zephyr] Rule ${index}: missing 'test' pattern`);\n    }\n    try {\n      new RegExp(rule.test);\n    } catch (e) {\n      console.error(`[Zephyr] Rule ${index}: invalid regex pattern`);\n    }\n  });\n\n  // Service Worker lifecycle\n  self.addEventListener('install', (event) => {\n    debugLog('Installing...');\n\n    // Execute precache if configured\n    if (config.eagerCache?.precache?.urls?.length > 0) {\n      event.waitUntil(\n        executePrecache(config.eagerCache.precache)\n          .then(() => self.skipWaiting())\n          .catch(error => {\n            debugLog('Precache error:', error.message);\n            // skipWaiting even on error if failSilently is true (default)\n            return self.skipWaiting();\n          })\n      );\n    } else {\n      self.skipWaiting();\n    }\n  });\n\n  self.addEventListener('activate', (event) => {\n    debugLog('Activated');\n    event.waitUntil(\n      Promise.all([\n        clients.claim(),\n        // Start manifest polling if configured\n        config.invalidation?.type === 'manifest'\n          ? startManifestPolling(config)\n          : Promise.resolve()\n      ])\n    );\n  });\n\n  // Message handler\n  self.addEventListener('message', async (event) => {\n    const { action, pattern, url } = event.data || {};\n    let result;\n\n    switch (action) {\n      case 'clear':\n        result = await clearAllCache();\n        break;\n      case 'clearPattern':\n      case 'invalidate':\n        result = await clearCacheByPattern(pattern);\n        break;\n      case 'invalidateUrl':\n        result = await clearCacheByUrl(url);\n        break;\n      case 'stats':\n        result = await getCacheStats();\n        break;\n      case 'quota':\n        result = await getQuotaUsage();\n        break;\n      case 'debug':\n        debugMode = !debugMode;\n        result = { debugMode };\n        break;\n      case 'prefetch':\n        result = await handlePrefetch(url);\n        break;\n      default:\n        result = { error: 'Unknown action' };\n    }\n\n    if (event.ports && event.ports[0]) {\n      event.ports[0].postMessage(result);\n    }\n  });\n\n  // Fetch handler\n  self.addEventListener('fetch', (event) => {\n    const request = event.request;\n    const url = new URL(request.url);\n\n    if (url.searchParams.get('zephyrDebug') === 'true') {\n      debugMode = true;\n      logAllCacheRecords();\n    }\n\n    const matchingRule = config.rules.find(rule => {\n      try {\n        const regex = new RegExp(rule.test);\n        return regex.test(request.url) && (!rule.method || rule.method === request.method);\n      } catch (e) {\n        return false;\n      }\n    });\n\n    if (!matchingRule) return;\n\n    const ruleTTL = parseInt(matchingRule.cache, 10) || 60;\n    const maxEntries = matchingRule.maxEntries || DEFAULT_MAX_ENTRIES;\n    const timeout = matchingRule.timeout || DEFAULT_TIMEOUT;\n    const fallback = getFallbackStrategy(matchingRule);\n    const versionHeader = config.invalidation?.header;\n\n    event.respondWith(\n      (async () => {\n        try {\n          // Get from cache\n          const cached = await getResponseFromIndexedDB(request, { maxStaleAge: fallback.maxStaleAge });\n\n          // Stale-while-revalidate strategy\n          if (fallback.strategy === 'stale-while-revalidate' && cached.response) {\n            stats.hits++;\n            logCacheHit(request.url);\n\n            // Return cached, revalidate in background\n            if (cached.needsRevalidation || cached.isExpired) {\n              // Background revalidation\n              (async () => {\n                try {\n                  const networkResponse = await fetchWithTimeout(request.clone(), timeout);\n                  const metadata = extractCacheMetadata(networkResponse);\n\n                  if (shouldCacheResponse(networkResponse, metadata)) {\n                    const ttl = calculateTTL(metadata, ruleTTL, respectHttpHeaders);\n                    await storeResponseInIndexedDB(request, networkResponse, ttl, matchingRule.test, metadata);\n                    await enforceCacheLimits(matchingRule.test, maxEntries);\n                  }\n                } catch (e) {\n                  debugLog('Background revalidation failed:', e.message);\n                }\n              })();\n            }\n\n            return cached.response;\n          }\n\n          // Check if needs revalidation (ETag/Last-Modified)\n          if (cached.response && cached.needsRevalidation && (cached.record.etag || cached.record.lastModified)) {\n            const revalidation = await revalidateWithServer(request, cached.record, timeout);\n\n            if (revalidation.notModified) {\n              stats.hits++;\n              logCacheHit(request.url);\n\n              // Update validUntil\n              cached.record.validUntil = Date.now() + ruleTTL * 60000;\n              const db = await openIndexedDB();\n              const tx = db.transaction(STORE_NAME, 'readwrite');\n              tx.objectStore(STORE_NAME).put(cached.record);\n\n              return cached.response;\n            }\n\n            if (revalidation.response) {\n              stats.misses++;\n              const metadata = extractCacheMetadata(revalidation.response);\n\n              if (shouldCacheResponse(revalidation.response, metadata)) {\n                const ttl = calculateTTL(metadata, ruleTTL, respectHttpHeaders);\n                storeResponseInIndexedDB(request, revalidation.response.clone(), ttl, matchingRule.test, metadata)\n                  .then(() => enforceCacheLimits(matchingRule.test, maxEntries));\n              }\n\n              return revalidation.response;\n            }\n          }\n\n          // Fresh cache hit\n          if (cached.response && !cached.isExpired) {\n            // Check version header invalidation\n            if (versionHeader && cached.record.cacheVersion) {\n              // Will be checked on next network request\n            }\n\n            stats.hits++;\n            logCacheHit(request.url);\n            return cached.response;\n          }\n\n          // Cache miss or expired - fetch from network\n          stats.misses++;\n          logCacheMiss(request.url);\n\n          const networkResponse = await fetchWithTimeout(request.clone(), timeout);\n          const metadata = extractCacheMetadata(networkResponse);\n\n          // Store version header if configured\n          if (versionHeader) {\n            metadata.cacheVersion = networkResponse.headers.get(versionHeader);\n          }\n\n          if (shouldCacheResponse(networkResponse, metadata)) {\n            const ttl = calculateTTL(metadata, ruleTTL, respectHttpHeaders);\n            storeResponseInIndexedDB(request, networkResponse.clone(), ttl, matchingRule.test, metadata)\n              .then(() => enforceCacheLimits(matchingRule.test, maxEntries))\n              .catch(() => {});\n          }\n\n          return networkResponse;\n\n        } catch (error) {\n          debugLog('Fetch error:', error.message);\n          stats.errors++;\n\n          // Fallback strategies\n          if (fallback.strategy === 'network-only') {\n            throw error;\n          }\n\n          // stale-if-error: Try to return stale cache\n          const stale = await getResponseFromIndexedDB(request, { maxStaleAge: fallback.maxStaleAge });\n\n          if (stale.response && !stale.isTooStale) {\n            debugLog('Returning stale cache due to network error');\n            return stale.response;\n          }\n\n          return new Response(JSON.stringify({\n            error: 'Network request failed',\n            message: error.message\n          }), {\n            status: 503,\n            statusText: 'Service Unavailable',\n            headers: { 'Content-Type': 'application/json' }\n          });\n        }\n      })()\n    );\n  });\n\n  debugLog('Initialized with', config.rules.length, 'rules');\n  if (config.invalidation) {\n    debugLog('Invalidation config:', config.invalidation.type || 'http-headers');\n  }\n  if (config.quota) {\n    debugLog('Quota config:', (config.quota.maxSize / 1024 / 1024).toFixed(0), 'MB max');\n  }\n}\n\n// Export for service worker context\nif (typeof self !== 'undefined') {\n  self.initZephyr = initZephyr;\n  self.zephyr = {\n    clear: clearAllCache,\n    clearPattern: clearCacheByPattern,\n    invalidate: clearCacheByPattern,\n    invalidateUrl: clearCacheByUrl,\n    stats: getCacheStats,\n    quota: getQuotaUsage,\n    debug: () => { debugMode = !debugMode; return debugMode; }\n  };\n}\n"],"names":["DB_NAME","STORE_NAME","debugMode","globalConfig","lastManifestVersion","currentStorageSize","stats","debugLog","message","args","logCacheHit","url","logCacheMiss","logRevalidation","hashPayload","payload","data","hashBuffer","b","hash","i","char","generateCacheKey","request","key","payloadHash","error","guessContentType","extension","fetchWithTimeout","timeout","resolve","reject","controller","timeoutId","response","parseCacheControl","header","directives","part","value","parseExpires","date","extractCacheMetadata","cacheControl","expires","calculateTTL","metadata","ruleTTL","respectHeaders","ttlMs","shouldCacheResponse","openIndexedDB","_a","event","db","store","storeResponseInIndexedDB","ttl","pattern","body","bodySize","checkQuota","headers","headerKey","now","record","tx","getResponseFromIndexedDB","options","getRequest","isExpired","isStale","maxStaleAge","isTooStale","contentType","blob","deleteCacheEntry","getReq","clearAllCache","clearCacheByPattern","regex","deleted","freedBytes","cursor","clearCacheByUrl","getCacheStats","countRequest","result","enforceCacheLimits","maxEntries","entries","a","toDelete","entry","additionalBytes","maxSize","warningThreshold","percentage","notifyQuotaWarning","evictLRUEntries","bytesNeeded","clientList","client","getQuotaUsage","startManifestPolling","config","interval","parser","r","pollManifest","manifest","invalidateByManifest","patterns","invalidated","timestamp","patternTime","revalidateWithServer","conditionalRequest","getFallbackStrategy","rule","logAllCacheRecords","records","tableData","findMatchingRule","method","executePrecache","precacheConfig","urls","retries","failSilently","urlsToCache","results","precacheUrl","succeeded","failed","notifyPrecacheComplete","retriesLeft","absoluteUrl","matchingRule","cached","handlePrefetch","total","initZephyr","respectHttpHeaders","index","_b","_c","action","fallback","versionHeader","networkResponse","e","revalidation","stale"],"mappings":"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"}